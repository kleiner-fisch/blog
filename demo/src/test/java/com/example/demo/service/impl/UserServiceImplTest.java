package com.example.demo.service.impl;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import org.assertj.core.util.Lists;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort.Direction;

import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.example.demo.exception.UserNotFoundException;
import com.example.demo.model.Post;
import com.example.demo.model.CustomUser;
import com.example.demo.repository.UserRepository;
import com.example.demo.service.UserService;

import static com.example.demo.service.DefaultValues.DELETED_USER;;


@Disabled
@DataJpaTest
public class UserServiceImplTest {

    @Mock
    private UserRepository userRepository;

    private UserService userService;
    private AutoCloseable autoClosable;
    private CustomUser testUserWithoutId;
    private CustomUser testUserWithId1;
    private CustomUser testUserWithId2;
    private Long userId;

    @BeforeEach
    private void setUp(){
        autoClosable = MockitoAnnotations.openMocks(this);
        userService = new UserServiceImpl(userRepository);
        testUserWithoutId = new CustomUser();
        testUserWithoutId.setMail("test@mail.com");
        testUserWithoutId.setPassword("abc");
        testUserWithoutId.setUsername("bob");

        testUserWithId1 = new CustomUser();
        testUserWithId1.setMail("othermail@mail.com");
        testUserWithId1.setPassword("abc");
        testUserWithId1.setUsername("alice");
        userId = 1L;
        testUserWithId1.setUserId(userId);

        testUserWithId2 = new CustomUser();
        testUserWithId2.setMail("louisa@mail.com");
        testUserWithId2.setPassword("abc");
        testUserWithId2.setUsername("louisa");
        testUserWithId2.setUserId(userId +1);
    }

    @AfterEach
    private void tearDown() throws Exception{
        autoClosable.close();

    }


    @Test
    void testCreateUser() {
        // The Ids are generated by the repository, that we mock here.
        //  Hence, we need to ensure that the user gets an ID.
        //  This usually happens when storing the usre
        doAnswer((InvocationOnMock invocation) -> {
            CustomUser tmpUser = (CustomUser) invocation.getArgument(0);
            tmpUser.setUserId(userId);
            return null;
        }).when(userRepository).save(testUserWithoutId);
        when(userRepository.save(testUserWithoutId)).thenReturn(testUserWithoutId);

        assertThat(userService.createUser(testUserWithoutId)).isEqualTo(testUserWithoutId.getUserId());
    }


    @Test
    void testGetUser_Found() {
        when(userRepository.findById(userId)).thenReturn(Optional.of(testUserWithId1));
        assertThat(userService.getUser(userId)).isEqualTo(testUserWithId1);
    }

    @Test
    void testGetUser_NotFound() {
        when(userRepository.findById(userId + 1)).thenReturn(Optional.empty());

        assertThrows(UserNotFoundException.class, 
            () -> userService.getUser(userId +1));      

    }

    @Test
    void testGetAllUsers() {
        int pageSize = 10;
        int pageNumber = 0;
        String sortDirection = "desc";
        String sortBy = "username";

        var pageRequest = PageRequest.of(pageNumber,pageSize, Direction.fromString(sortDirection), sortBy);
        Page<CustomUser> result = new PageImpl(Lists.list(testUserWithId2, testUserWithId1));
        when(userRepository.findAll(pageRequest)).thenReturn(result);

        assertThat(userService.getAllUsers(Optional.of(pageSize), 
                    Optional.of(pageNumber), 
                    Optional.of(sortBy), 
                    Optional.of(sortDirection))).isEqualTo(result);

    }

    /**
     * Tests with the default options to getAllUsers()
     */
    @Test
    void testGetAllUsers_DefaultValues() {
        int pageSize = UserServiceImpl.DEFAULT_PAGE_LIMIT;
        int pageNumber = UserServiceImpl.DEFAULT_PAGE_OFFSET;
        String sortDirection = "asc";
        String sortBy = "userId";

        var pageRequest = PageRequest.of(pageNumber,pageSize, Direction.fromString(sortDirection), sortBy);
        //Page<User> result = new PageImpl(Collections.singletonList(testUserWithId1));
        Page<CustomUser> result = new PageImpl(Lists.list(testUserWithId1, testUserWithId2));

        when(userRepository.findAll(pageRequest)).thenReturn(result);

        assertThat(userService.getAllUsers()).isEqualTo(result);
                
    }

    /**
     * We test whether the userService passes its values on to the userRepository.
     * 
     * We do this because we abstract from the actual saving in the database
     */
    @Test
    void testAddAllUsers() {
        var users = Lists.list(testUserWithId1, testUserWithId2);

        ArgumentCaptor<Collection<CustomUser>> savedCaptor = ArgumentCaptor.forClass(Collection.class);
        userService.addAllUsers(users);
        verify(userRepository).saveAll(savedCaptor.capture());   
        assertTrue(savedCaptor.getValue().containsAll(users));
        assertThat(savedCaptor.getValue().size()).isEqualTo(users.size());
    }




    @Test
    void testDeleteUser_NotFound() {
        when(userRepository.existsById(anyLong())).thenReturn(false);

        assertThrows(UserNotFoundException.class, 
            () -> userService.deleteUser(userId));    
    }

    @Test
    void testDeleteUser_Found() {
        when(userRepository.existsById(anyLong())).thenReturn(true);
        CustomUser toDelete = testUserWithId2;
        CustomUser specialDeletedUser = testUserWithId1;
        specialDeletedUser.setPosts(new ArrayList<>());
        specialDeletedUser.setUsername(DELETED_USER);

        Post post = new Post(1L, "Test Title", "Test Content", toDelete, null, Collections.emptyList());
        //toDelete.setPosts(new ArrayList<Post>(Arrays.asList(post)));
        toDelete.setPosts(Stream.of(post).collect(Collectors.toList()));


        when(userRepository.getReferenceById(anyLong())).thenReturn(toDelete);
        when(userRepository.findByUsername(DELETED_USER)).thenReturn(Optional.of(specialDeletedUser));

        userService.deleteUser(toDelete.getUserId());

        // Check that userRepository.delete(toDelete) was called
        ArgumentCaptor<CustomUser> savedCaptor = ArgumentCaptor.forClass(CustomUser.class);
        verify(userRepository).delete(savedCaptor.capture());   
        assertThat(savedCaptor.getValue()).isEqualTo(toDelete);

        // Check that the posts of the deleted user are assigned to the specialDeletedUser
        assertTrue(toDelete.getPosts().isEmpty());
        assertFalse(specialDeletedUser.getPosts().isEmpty());
    }


    @Test
    void testDeleteAllUsers() {
        // TODO write me
    }

    @Test
    void testFlush() {
        // TODO write me

    }





    @Test
    void testUpdateUser() {
        // TODO write me

    }
}
